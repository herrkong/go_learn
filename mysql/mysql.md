
#### 1 MySql 之一条查询sql的执行过程

mysql client --> server 维护一条长链接  连接器
查询缓存  之前查过会记录缓存  更新表会清掉缓存
分析器 分析sql语句的 词法分析：识别操作类型 表名 字段 语法分析：语法正确性
优化器  优先哪个索引 查找策略
执行器 mysql 引擎 innnodb   底层数据结构 b+树



##### mysql -h ${host} -p ${port} -u${name} -p 

##### 连接器 
去权限表中查权限 保持wait_time的长链接  超时重新连接

##### 查询缓存
成功连接 执行sql成功查询 会将sql作为key 查询结果作为value 存入缓存 下次再查询会直接查询缓存

但是update操作会清空该表的所有缓存  活跃更新的表不适合做查询缓存 

mysql 8.0 版本已经把缓存功能完全移除

##### 分析器

sql语句进行 “词法分析” 和 “语法分析”

“词法分析” : 识别操作类型 识别表名 识别字段名

“语法分析”: 检查sql语句 语法


##### 优化器

某表有多个索引的时候 决定用哪一个索引

多关联（join）查询的时候，决定关联的顺序

select * from user u join  score s using(ID)  where u.id=20 and s.scores=80;

既可以先从表user里面取出id=20的记录的ID值，再根据ID值关联到表socre，再判断score表里scores的值是否等于80。
也可以先从表score里面取出scores=80的记录的ID值，再根据ID值关联到user，再判断user表里面id的值是否等于20。

依据执行效率选择


##### 执行器

先检查权限 

默认引擎还是 指定的引擎 默认innodb 底层都是b+树 

判断数据项 该行不符合 则继续下一行

直到取到满足所有查询条件的行 
执行器将查询结果返回给客户端

####
mysql -h$ip -P$端口 -u$登录名 -p 

mysql -h ${host} -p ${port} -u${name} -p 



#### 3 	mysql底层有哪几种实现方式 


在某个字段上建索引，意思就是让 MySQL 对该字段以索引这种数据结构来存储，然后查找的时候就有对应的查找算法。

目前大多数数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。
B+ 树索引是 B+ 树在数据库中的一种实现，是最常见也是数据库中使用最为频繁的一种索引。B+ 树中的 B 代表平衡，而不是二叉。

因为 B+ 树是从最早的平衡二叉树演化而来的。B+ 树是由二叉查找树、平衡二叉树（AVLTree）和平衡多路查找树（B-Tree）逐步优化而来。

二叉查找树：左子树的键值小于根的键值，右子树的键值大于根的键值。

AVL 树：平衡二叉树（AVL 树）在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为 1。

平衡多路查找树（B-Tree）：为磁盘等外存储设备设计的一种平衡查找树。



#### 

二叉查找树 

平衡二叉树

平衡多路查找树 B树


#### 为什么 MySQL 的索引要使用 B+树而不是其它树形结构?比如 B 树？
https://segmentfault.com/a/1190000021488885

更稳定的查询效率：B树的查询时间复杂度在1到树高之间(分别对应记录在根节点和叶节点)，而B+树的查询复杂度则稳定为树高，因为所有数据都在叶节点


B+树的最大元素始终位于根节点当中。所有叶子节点包含了全量元素信息，并且每一个叶子节点都带有指向 下一个节点指针，形成了一个有序链表。

B+树更加矮胖 树高很低


b+树相比b树 
1 每个叶子结点存储数据 且节点存储的数据更多 叶子结点之间 形成一个有序链表 存储指向下一个叶子结点的指针 非常适合范围查询 
范围查询的优势 是为什么mysql底层使用b+树 而不是hash的原因 虽然hash O(1) 查表范围查询 b+树更加有优势

2 查询的稳定性更好  始终是树高  而b树 是1～树高之间



#### b+树的优势

1 单一节点存储更多的元素，使得查询的IO次数更少。
2 所有查询都要查找到叶子节点，查询性能稳定。 
3 所有叶子节点形成有序链表，便于范围查询。

叶子节点 形成有序链表



#### MySQL中存储索引用到的数据结构是B+树，B+树的查询时间跟树的高度有关，是log(n)，如果用hash存储，那么查询时间是O(1)。既然hash比B+树更快，为什么mysql用B+树来存储索引呢？

1 内存上 数据库的数据存在磁盘中 这么大数据量没法一次性全部存入内存  B+树的设计是可以分批载入数据
2 业务角度来说 查一条数据当然不如hash存 但是数据库经常是范围查找  b+叶子节点 数据 构成了有序的链表 效率更高

#### 为什么不用红黑树或者二叉排序树？

B树是多路树，红黑树是二叉树！红黑树一个节点只能存出一个值，B树一个节点可以存储多个值，红黑树的深度会更大,定位时 红黑树的查找次数会大一些。
用红黑树 树深过大


AVL 数和红黑树基本都是存储在内存中才会使用的数据结构 map


b/b+ 树是多路查找树 红黑树是二叉树  且每个节点只能存一个值  树深更高 查找次数更大




#### 既然增加树的路数可以降低树的高度，那么无限增加树的路数是不是可以有最优的查找效率？

不可以。因为这样会形成一个有序数组，文件系统和数据库的索引都是存在硬盘上的，并且如果数据量 大的话，不一定能一次性加载到内存中。
有序数组没法一次性加载进内存，这时候B+树的多路存储威力 就出来了，可以每次加载B+树的一个结点，然后一步步往下找，

有序数组 数据量大要存硬盘的  不能一次性加载到内存 
b+树是可以分批加载内存的



#### 在内存中，红黑树比B树更优，但是涉及到磁盘操作B树就更优了，那么你能讲讲B+树吗？
B+树是在B树的基础上进行改造，它的数据都在叶子结点，同时叶子结点之间还加了指针形成链表。

#### 为什么B+树要这样设计？
便于范围查询

select * from  


